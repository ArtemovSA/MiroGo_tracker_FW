//=========================================================
// src/InitDevice.c: generated by Hardware Configurator
//
// This file will be regenerated when saving a document.
// leave the sections inside the "$[...]" comment tags alone
// or they will be overwritten!
//=========================================================

// USER INCLUDES
#include "InitDevice.h"

// USER PROTOTYPES
// USER FUNCTIONS

// $[Library includes]
#include "em_system.h"
#include "em_emu.h"
#include "em_cmu.h"
#include "em_device.h"
#include "em_chip.h"
#include "em_assert.h"
#include "em_adc.h"
#include "em_aes.h"
#include "em_burtc.h"
#include "em_rmu.h"
#include "em_gpio.h"
#include "em_i2c.h"
#include "em_rtc.h"
#include "em_timer.h"
#include "em_usart.h"
#include "em_wdog.h"
// [Library includes]$

//==============================================================================
// enter_DefaultMode_from_RESET
//==============================================================================
extern void enter_DefaultMode_from_RESET(void) {
	// $[Config Calls]
	CHIP_Init();

	HFXO_enter_DefaultMode_from_RESET();
	LFXO_enter_DefaultMode_from_RESET();
	CMU_enter_DefaultMode_from_RESET();
        
#ifndef BOOTLOADER
        RTC_enter_DefaultMode_from_RESET();
        USART1_enter_DefaultMode_from_RESET();
#endif
        
	ADC0_enter_DefaultMode_from_RESET();
	//BURTC_enter_DefaultMode_from_RESET();
	USART0_enter_DefaultMode_from_RESET();
	WDOG_enter_DefaultMode_from_RESET();
	I2C0_enter_DefaultMode_from_RESET();
	TIMER0_enter_DefaultMode_from_RESET();
	PORTIO_enter_DefaultMode_from_RESET();
        TIMER1_enter_DefaultMode_from_RESET();
	// [Config Calls]$

}

//================================================================================
// HFXO_enter_DefaultMode_from_RESET
//================================================================================
extern void HFXO_enter_DefaultMode_from_RESET(void) {

	// $[HFXO]
	CMU->CTRL = (CMU->CTRL & ~_CMU_CTRL_HFXOMODE_MASK) | CMU_CTRL_HFXOMODE_XTAL;

	CMU->CTRL = (CMU->CTRL & ~_CMU_CTRL_HFXOBOOST_MASK)
			| CMU_CTRL_HFXOBOOST_50PCENT;

	SystemHFXOClockSet(48000000);
	// [HFXO]$

}

//================================================================================
// LFXO_enter_DefaultMode_from_RESET
//================================================================================
extern void LFXO_enter_DefaultMode_from_RESET(void) {

	// $[Use oscillator source]
	CMU->CTRL = (CMU->CTRL & ~_CMU_CTRL_LFXOMODE_MASK) | CMU_CTRL_LFXOMODE_XTAL;
	// [Use oscillator source]$

	// $[LFXO Boost Percent]
	CMU->CTRL = (CMU->CTRL & ~_CMU_CTRL_LFXOBOOST_MASK)
			| CMU_CTRL_LFXOBOOST_100PCENT;
	// [LFXO Boost Percent]$

	// $[REDLFXO Boost]
	// [REDLFXO Boost]$

}

//================================================================================
// CMU_enter_DefaultMode_from_RESET
//================================================================================
extern void CMU_enter_DefaultMode_from_RESET(void) {

	// $[LFXO enable]
	CMU_OscillatorEnable(cmuOsc_LFXO, true, true);
	// [LFXO enable]$

	// $[HFXO enable]
	CMU_OscillatorEnable(cmuOsc_HFXO, true, true);
	// [HFXO enable]$

	// $[LFACLK Setup]
	/* Select LFXO as clock source for LFACLK */
	CMU_ClockSelectSet(cmuClock_LFA, cmuSelect_LFXO);

	// [LFACLK Setup]$

	// $[High Frequency Clock select]
	/* Using HFXO as high frequency clock, HFCLK */
	CMU_ClockSelectSet(cmuClock_HF, cmuSelect_HFXO);
        //CMU_ClockSelectSet(cmuClock_HF, cmuSelect_HFRCO);
        //cmuSelect_HFRCO

	/* Enable peripheral clock */
	CMU_ClockEnable(cmuClock_HFPER, true);

	// [High Frequency Clock select]$

	// $[LF clock tree setup]
	/* Enable LF clocks */
	CMU_ClockEnable(cmuClock_CORELE, true);
	//CMU_ClockSelectSet(cmuClock_LFA, cmuSelect_LFXO);
        CMU_ClockDivSet(cmuClock_RTC, cmuClkDiv_32768); //1Hz
        CMU_ClockSelectSet(cmuClock_LFB, cmuSelect_LFXO);
	// [LF clock tree setup]$

	// $[Peripheral Clock enables]
	/* Enable clock for ADC0 */
	CMU_ClockEnable(cmuClock_ADC0, true);

	/* Enable clock for AES */
	CMU_ClockEnable(cmuClock_AES, true);

	/* Enable clock for I2C0 */
	CMU_ClockEnable(cmuClock_I2C0, true);

	/* Enable clock for RTC */
	CMU_ClockEnable(cmuClock_RTC, true);

	/* Enable clock for TIMER0 */
	CMU_ClockEnable(cmuClock_TIMER0, true);
        
        CMU_ClockEnable(cmuClock_TIMER1, true);

	/* Enable clock for USART0 */
	CMU_ClockEnable(cmuClock_USART0, true);

	/* Enable clock for USART1 */
	CMU_ClockEnable(cmuClock_USART1, true);

	/* Enable clock for GPIO by default */
	CMU_ClockEnable(cmuClock_GPIO, true);
        
        CMU_ClockEnable(cmuClock_USB, true);

	// [Peripheral Clock enables]$

}

//================================================================================
// ADC0_enter_DefaultMode_from_RESET
//================================================================================
extern void ADC0_enter_DefaultMode_from_RESET(void) {

	// $[ADC_Init]
	ADC_Init_TypeDef init = ADC_INIT_DEFAULT;

	init.ovsRateSel = adcOvsRateSel2;
	init.lpfMode = adcLPFilterBypass;
	init.warmUpMode = adcWarmupNormal;
	init.timebase = ADC_TimebaseCalc(0);
	init.prescale = ADC_PrescaleCalc(7000000, 0);
	init.tailgate = 0;

	ADC_Init(ADC0, &init);
	// [ADC_Init]$

	// $[ADC_InitSingle]
	// [ADC_InitSingle]$

	// $[ADC_InitScan]
	// [ADC_InitScan]$

}

//================================================================================
// ACMP0_enter_DefaultMode_from_RESET
//================================================================================
extern void ACMP0_enter_DefaultMode_from_RESET(void) {

	// $[ACMP Initialization]
	// [ACMP Initialization]$

	// $[ACMP Channel config]
	// [ACMP Channel config]$

}

//================================================================================
// ACMP1_enter_DefaultMode_from_RESET
//================================================================================
extern void ACMP1_enter_DefaultMode_from_RESET(void) {

	// $[ACMP Initialization]
	// [ACMP Initialization]$

	// $[ACMP Channel config]
	// [ACMP Channel config]$

}

//================================================================================
// DAC0_enter_DefaultMode_from_RESET
//================================================================================
extern void DAC0_enter_DefaultMode_from_RESET(void) {

	// $[DAC Initialization]
	// [DAC Initialization]$

	// $[DAC Channel 0 config]
	// [DAC Channel 0 config]$

	// $[DAC Channel 1 config]
	// [DAC Channel 1 config]$

}

//================================================================================
// BURTC_enter_DefaultMode_from_RESET
//================================================================================
extern void BURTC_enter_DefaultMode_from_RESET(void) {

	// $[CMU_ClockEnable]
	/* Enable LE clock for CPU access to BURTC registers */
	CMU_ClockEnable(cmuClock_CORELE, true);
	// [CMU_ClockEnable]$

	// $[CMU_OscillatorEnable]
	CMU_OscillatorEnable(cmuOsc_ULFRCO, true, true);
	// [CMU_OscillatorEnable]$

	// $[RMU_ResetControl]
	/* Release reset line to backup domain. This is needed before the CPU can access
	 * BURTC registers */
	RMU_ResetControl(rmuResetBU, false);
	// [RMU_ResetControl]$

	// $[BURTC_Init]
	BURTC_Init_TypeDef init = BURTC_INIT_DEFAULT;

	init.enable = false;
	init.mode = burtcModeEM3;
	init.debugRun = false;
	init.clkSel = burtcClkSelULFRCO;
	init.clkDiv = burtcClkDiv_32;
	init.timeStamp = false;
	init.compare0Top = true;
	init.lowPowerMode = burtcLPDisable;
	init.lowPowerComp = 0;
	BURTC_Init(&init);
	// [BURTC_Init]$

	// $[BURTC_CompareSet]
	/* Set compare value */
	BURTC_CompareSet(0, 99);
	// [BURTC_CompareSet]$

}

//================================================================================
// RTC_enter_DefaultMode_from_RESET
//================================================================================
extern void RTC_enter_DefaultMode_from_RESET(void) {

	// $[RTC_Init]
	RTC_Init_TypeDef init = RTC_INIT_DEFAULT;

	init.debugRun = true;
	init.comp0Top = false;

	RTC_Init(&init);
        RTC_Enable(false);
	// [RTC_Init]$

}

//================================================================================
// OPAMP0_enter_DefaultMode_from_RESET
//================================================================================
extern void OPAMP0_enter_DefaultMode_from_RESET(void) {

	// $[DAC Output]
	// [DAC Output]$

	// $[OPAMP_Enable]
	// [OPAMP_Enable]$

}

//================================================================================
// OPAMP1_enter_DefaultMode_from_RESET
//================================================================================
extern void OPAMP1_enter_DefaultMode_from_RESET(void) {

	// $[DAC Output]
	// [DAC Output]$

	// $[OPAMP_Enable]
	// [OPAMP_Enable]$

}

//================================================================================
// OPAMP2_enter_DefaultMode_from_RESET
//================================================================================
extern void OPAMP2_enter_DefaultMode_from_RESET(void) {

	// $[DAC Output]
	// [DAC Output]$

	// $[OPAMP_Enable]
	// [OPAMP_Enable]$

}

//================================================================================
// USART0_enter_DefaultMode_from_RESET
//================================================================================
extern void USART0_enter_DefaultMode_from_RESET(void) {

	// $[USART_InitAsync]
	// [USART_InitAsync]$

	// $[USART_InitSync]
	USART_InitSync_TypeDef initsync = USART_INITSYNC_DEFAULT;

	initsync.baudrate = 1000000;
	initsync.databits = usartDatabits8;
	initsync.master = 1;
	initsync.msbf = 1;
	initsync.clockMode = usartClockMode0;
#if defined( USART_INPUT_RXPRS ) && defined( USART_TRIGCTRL_AUTOTXTEN )
	initsync.prsRxEnable = 0;
	initsync.prsRxCh = 0;
	initsync.autoTx = 0;
#endif

	USART_InitSync(USART0, &initsync);
	// [USART_InitSync]$

	// $[USART_InitPrsTrigger]
	USART_PrsTriggerInit_TypeDef initprs = USART_INITPRSTRIGGER_DEFAULT;

	initprs.rxTriggerEnable = 0;
	initprs.txTriggerEnable = 0;
	initprs.prsTriggerChannel = usartPrsTriggerCh0;

	USART_InitPrsTrigger(USART0, &initprs);
	// [USART_InitPrsTrigger]$

}

//================================================================================
// USART1_enter_DefaultMode_from_RESET
//================================================================================
extern void USART1_enter_DefaultMode_from_RESET(void) {

	// $[USART_InitAsync]
	USART_InitAsync_TypeDef initasync = USART_INITASYNC_DEFAULT;

	initasync.baudrate = 115200;
	initasync.databits = usartDatabits8;
	initasync.parity = usartNoParity;
	initasync.stopbits = usartStopbits1;
	initasync.oversampling = usartOVS16;
#if defined( USART_INPUT_RXPRS ) && defined( USART_CTRL_MVDIS )
	initasync.mvdis = 1;
	initasync.prsRxEnable = 0;
	initasync.prsRxCh = 0;
#endif

	USART_InitAsync(USART1, &initasync);
	// [USART_InitAsync]$

	// $[USART_InitSync]
	// [USART_InitSync]$

	// $[USART_InitPrsTrigger]
	USART_PrsTriggerInit_TypeDef initprs = USART_INITPRSTRIGGER_DEFAULT;

	initprs.rxTriggerEnable = 0;
	initprs.txTriggerEnable = 0;
	initprs.prsTriggerChannel = usartPrsTriggerCh0;

	USART_InitPrsTrigger(USART1, &initprs);
	// [USART_InitPrsTrigger]$
        
        USART_Enable(USART1, usartEnable);

}

//================================================================================
// USART2_enter_DefaultMode_from_RESET
//================================================================================
extern void USART2_enter_DefaultMode_from_RESET(void) {

	// $[USART_InitAsync]
	// [USART_InitAsync]$

	// $[USART_InitSync]
	// [USART_InitSync]$

	// $[USART_InitPrsTrigger]
	// [USART_InitPrsTrigger]$

}

//================================================================================
// LEUART0_enter_DefaultMode_from_RESET
//================================================================================
extern void LEUART0_enter_DefaultMode_from_RESET(void) {

	// $[LEUART0 initialization]
	// [LEUART0 initialization]$

}

//================================================================================
// LEUART1_enter_DefaultMode_from_RESET
//================================================================================
extern void LEUART1_enter_DefaultMode_from_RESET(void) {

	// $[LEUART1 initialization]
	// [LEUART1 initialization]$

}

//================================================================================
// VCMP_enter_DefaultMode_from_RESET
//================================================================================
extern void VCMP_enter_DefaultMode_from_RESET(void) {

	// $[VCMP_Init]
	// [VCMP_Init]$

}

//================================================================================
// WDOG_enter_DefaultMode_from_RESET
//================================================================================
extern void WDOG_enter_DefaultMode_from_RESET(void) {

	// $[CMU_ClockEnable]
	/* Enable LE clock for CPU access to BURTC registers */
	CMU_ClockEnable(cmuClock_CORELE, true);
	// [CMU_ClockEnable]$

	// $[CMU_OscillatorEnable]
	CMU_OscillatorEnable(cmuOsc_LFRCO, true, true);
	// [CMU_OscillatorEnable]$

	// $[WDOG_Init]
	WDOG_Init_TypeDef watchdogInit = WDOG_INIT_DEFAULT;

	watchdogInit.debugRun = 0;
	watchdogInit.clkSel = wdogClkSelULFRCO;
	watchdogInit.perSel = wdogPeriod_256k;
	watchdogInit.swoscBlock = 0;
	watchdogInit.em4Block = 0;
	watchdogInit.lock = 0;
	watchdogInit.em3Run = 1;
	watchdogInit.em2Run = 1;
	WDOG_Init(&watchdogInit);
	// [WDOG_Init]$

}

//================================================================================
// I2C0_enter_DefaultMode_from_RESET
//================================================================================
extern void I2C0_enter_DefaultMode_from_RESET(void) {

	// $[I2C0 initialization]
	I2C_Init_TypeDef init = I2C_INIT_DEFAULT;

	init.enable = 1;
	init.master = 1;
	init.freq = I2C_FREQ_FAST_MAX;
	init.clhr = i2cClockHLRAsymetric;
	I2C_Init(I2C0, &init);
	// [I2C0 initialization]$

}

//================================================================================
// I2C1_enter_DefaultMode_from_RESET
//================================================================================
extern void I2C1_enter_DefaultMode_from_RESET(void) {

	// $[I2C1 initialization]
	// [I2C1 initialization]$

}

//================================================================================
// TIMER0_enter_DefaultMode_from_RESET
//================================================================================
extern void TIMER0_enter_DefaultMode_from_RESET(void) {

	// $[TIMER0 initialization]
	TIMER_Init_TypeDef init = TIMER_INIT_DEFAULT;

	init.enable = 1;
	init.debugRun = 0;
	init.dmaClrAct = 0;
	init.sync = 0;
	init.clkSel = timerClkSelHFPerClk;
	init.prescale = timerPrescale1;
	init.fallAction = timerInputActionNone;
	init.riseAction = timerInputActionNone;
	init.mode = timerModeUp;
	init.quadModeX4 = 0;
	init.oneShot = 0;
	init.count2x = 0;
	init.ati = 0;
	TIMER_Init(TIMER0, &init);
	// [TIMER0 initialization]$

	// $[TIMER0 CC0 init]
	TIMER_InitCC_TypeDef initCC0 = TIMER_INITCC_DEFAULT;

	initCC0.prsInput = false;
	initCC0.prsSel = timerPRSSELCh0;
	initCC0.edge = timerEdgeRising;
	initCC0.mode = timerCCModeOff;
	initCC0.eventCtrl = timerEventEveryEdge;
	initCC0.filter = 0;
	initCC0.cofoa = timerOutputActionNone;
	initCC0.cufoa = timerOutputActionNone;
	initCC0.cmoa = timerOutputActionNone;
	initCC0.coist = 0;
	initCC0.outInvert = 0;
	TIMER_InitCC(TIMER0, 0, &initCC0);
	// [TIMER0 CC0 init]$

	// $[TIMER0 CC1 init]
	TIMER_InitCC_TypeDef initCC1 = TIMER_INITCC_DEFAULT;

	initCC1.prsInput = false;
	initCC1.prsSel = timerPRSSELCh0;
	initCC1.edge = timerEdgeRising;
	initCC1.mode = timerCCModeOff;
	initCC1.eventCtrl = timerEventEveryEdge;
	initCC1.filter = 0;
	initCC1.cofoa = timerOutputActionNone;
	initCC1.cufoa = timerOutputActionNone;
	initCC1.cmoa = timerOutputActionNone;
	initCC1.coist = 0;
	initCC1.outInvert = 0;
	TIMER_InitCC(TIMER0, 1, &initCC1);
	// [TIMER0 CC1 init]$

	// $[TIMER0 CC2 init]
	TIMER_InitCC_TypeDef initCC2 = TIMER_INITCC_DEFAULT;

	initCC2.prsInput = false;
	initCC2.prsSel = timerPRSSELCh0;
	initCC2.edge = timerEdgeRising;
	initCC2.mode = timerCCModeOff;
	initCC2.eventCtrl = timerEventEveryEdge;
	initCC2.filter = 0;
	initCC2.cofoa = timerOutputActionNone;
	initCC2.cufoa = timerOutputActionNone;
	initCC2.cmoa = timerOutputActionNone;
	initCC2.coist = 0;
	initCC2.outInvert = 0;
	TIMER_InitCC(TIMER0, 2, &initCC2);
	// [TIMER0 CC2 init]$

	// $[TIMER0 DTI init]
	TIMER_InitDTI_TypeDef initDTI = TIMER_INITDTI_DEFAULT;

	initDTI.enable = 0;
	initDTI.activeLowOut = 0;
	initDTI.invertComplementaryOut = 0;
	initDTI.autoRestart = 0;
	initDTI.enablePrsSource = 0;
	initDTI.prsSel = timerPRSSELCh0;
	initDTI.prescale = timerPrescale1;
	initDTI.riseTime = 1;
	initDTI.fallTime = 1;
	initDTI.enableFaultSourceCoreLockup = 1;
	initDTI.enableFaultSourceDebugger = 1;
	initDTI.faultSourcePrsSel0 = 0;
	initDTI.faultSourcePrsSel0 = timerPRSSELCh0;
	initDTI.faultSourcePrsSel1 = 0;
	initDTI.faultSourcePrsSel1 = timerPRSSELCh0;
	initDTI.faultAction = timerDtiFaultActionInactive;
	initDTI.outputsEnableMask = 0;
	TIMER_InitDTI(TIMER0, &initDTI);
	// [TIMER0 DTI init]$

}

//================================================================================
// TIMER1_enter_DefaultMode_from_RESET
//================================================================================
extern void TIMER1_enter_DefaultMode_from_RESET(void) {
  
  // $[TIMER1 initialization]
  TIMER_Init_TypeDef init = TIMER_INIT_DEFAULT;
  
  init.enable = 1;
  init.debugRun = 0;
  init.dmaClrAct = 0;
  init.sync = 0;
  init.clkSel = timerClkSelHFPerClk;
  init.prescale = timerPrescale1;
  init.fallAction = timerInputActionNone;
  init.riseAction = timerInputActionNone;
  init.mode = timerModeUp;
  init.quadModeX4 = 0;
  init.oneShot = 0;
  init.count2x = 0;
  init.ati = 0;
  TIMER_Init(TIMER1, &init);
  // [TIMER1 initialization]$
  
  // $[TIMER1 CC0 init]
  TIMER_InitCC_TypeDef initCC0 = TIMER_INITCC_DEFAULT;
  
  initCC0.prsInput = false;
  initCC0.prsSel = timerPRSSELCh0;
  initCC0.edge = timerEdgeRising;
  initCC0.mode = timerCCModeOff;
  initCC0.eventCtrl = timerEventEveryEdge;
  initCC0.filter = 0;
  initCC0.cofoa = timerOutputActionNone;
  initCC0.cufoa = timerOutputActionNone;
  initCC0.cmoa = timerOutputActionNone;
  initCC0.coist = 0;
  initCC0.outInvert = 0;
  TIMER_InitCC(TIMER1, 0, &initCC0);
  // [TIMER1 CC0 init]$
  
  // $[TIMER1 CC1 init]
  TIMER_InitCC_TypeDef initCC1 = TIMER_INITCC_DEFAULT;
  
  initCC1.prsInput = false;
  initCC1.prsSel = timerPRSSELCh0;
  initCC1.edge = timerEdgeRising;
  initCC1.mode = timerCCModeOff;
  initCC1.eventCtrl = timerEventEveryEdge;
  initCC1.filter = 0;
  initCC1.cofoa = timerOutputActionNone;
  initCC1.cufoa = timerOutputActionNone;
  initCC1.cmoa = timerOutputActionNone;
  initCC1.coist = 0;
  initCC1.outInvert = 0;
  TIMER_InitCC(TIMER1, 1, &initCC1);
  // [TIMER1 CC1 init]$
  
  // $[TIMER1 CC2 init]
  TIMER_InitCC_TypeDef initCC2 = TIMER_INITCC_DEFAULT;
  
  initCC2.prsInput = false;
  initCC2.prsSel = timerPRSSELCh0;
  initCC2.edge = timerEdgeRising;
  initCC2.mode = timerCCModeOff;
  initCC2.eventCtrl = timerEventEveryEdge;
  initCC2.filter = 0;
  initCC2.cofoa = timerOutputActionNone;
  initCC2.cufoa = timerOutputActionNone;
  initCC2.cmoa = timerOutputActionNone;
  initCC2.coist = 0;
  initCC2.outInvert = 0;
  TIMER_InitCC(TIMER1, 2, &initCC2);
  // [TIMER1 CC2 init]$
  
}

//================================================================================
// TIMER2_enter_DefaultMode_from_RESET
//================================================================================
extern void TIMER2_enter_DefaultMode_from_RESET(void) {

	// $[TIMER2 initialization]
	// [TIMER2 initialization]$

	// $[TIMER2 CC0 init]
	// [TIMER2 CC0 init]$

	// $[TIMER2 CC1 init]
	// [TIMER2 CC1 init]$

	// $[TIMER2 CC2 init]
	// [TIMER2 CC2 init]$

}

//================================================================================
// TIMER3_enter_DefaultMode_from_RESET
//================================================================================
extern void TIMER3_enter_DefaultMode_from_RESET(void) {

	// $[TIMER3 initialization]
	// [TIMER3 initialization]$

	// $[TIMER3 CC0 init]
	// [TIMER3 CC0 init]$

	// $[TIMER3 CC1 init]
	// [TIMER3 CC1 init]$

	// $[TIMER3 CC2 init]
	// [TIMER3 CC2 init]$

}

//================================================================================
// LETIMER0_enter_DefaultMode_from_RESET
//================================================================================
extern void LETIMER0_enter_DefaultMode_from_RESET(void) {

	// $[LETIMER0_Init]
	// [LETIMER0_Init]$

}

//================================================================================
// PCNT0_enter_DefaultMode_from_RESET
//================================================================================
extern void PCNT0_enter_DefaultMode_from_RESET(void) {

	// $[PCNT0 initialization]
	// [PCNT0 initialization]$

}

//================================================================================
// PCNT1_enter_DefaultMode_from_RESET
//================================================================================
extern void PCNT1_enter_DefaultMode_from_RESET(void) {

	// $[PCNT1 initialization]
	// [PCNT1 initialization]$

}

//================================================================================
// PCNT2_enter_DefaultMode_from_RESET
//================================================================================
extern void PCNT2_enter_DefaultMode_from_RESET(void) {

	// $[PCNT2 initialization]
	// [PCNT2 initialization]$

}

//================================================================================
// PRS_enter_DefaultMode_from_RESET
//================================================================================
extern void PRS_enter_DefaultMode_from_RESET(void) {

	// $[PRS initialization]
	// [PRS initialization]$

}

//================================================================================
// ETM_enter_DefaultMode_from_RESET
//================================================================================
extern void ETM_enter_DefaultMode_from_RESET(void) {

	// $[ETM initialization]
	// [ETM initialization]$

}

//================================================================================
// PORTIO_enter_DefaultMode_from_RESET
//================================================================================
extern void PORTIO_enter_DefaultMode_from_RESET(void) {

	// $[Port A Configuration]
	GPIO->P[0].CTRL = (GPIO->P[0].CTRL & ~_GPIO_P_CTRL_DRIVEMODE_MASK)
			| GPIO_P_CTRL_DRIVEMODE_LOW;
  
	/* Pin PA0 is configured to Open-drain with pull-up and filter */
	GPIO->P[0].MODEL = (GPIO->P[0].MODEL & ~_GPIO_P_MODEL_MODE0_MASK)
			| GPIO_P_MODEL_MODE0_WIREDANDPULLUPFILTER;

	/* Pin PA1 is configured to Open-drain with pull-up and filter */
	GPIO->P[0].MODEL = (GPIO->P[0].MODEL & ~_GPIO_P_MODEL_MODE1_MASK)
			| GPIO_P_MODEL_MODE1_WIREDANDPULLUPFILTER;

	/* Pin PA2 is configured to Input enabled with pull-down and filter */
	GPIO->P[0].MODEL = (GPIO->P[0].MODEL & ~_GPIO_P_MODEL_MODE2_MASK)
			| GPIO_P_MODEL_MODE2_INPUTPULLFILTER;

	/* Pin PA3 is configured to Input enabled with pull-down and filter */
	GPIO->P[0].MODEL = (GPIO->P[0].MODEL & ~_GPIO_P_MODEL_MODE3_MASK)
			| GPIO_P_MODEL_MODE3_INPUTPULLFILTER;

	/* Pin PA8 is configured to Push-pull with alt. drive strength */
	GPIO->P[0].MODEH = (GPIO->P[0].MODEH & ~_GPIO_P_MODEH_MODE8_MASK)
			| GPIO_P_MODEH_MODE8_PUSHPULLDRIVE;

	/* Pin PA9 is configured to Push-pull with alt. drive strength */
	GPIO->P[0].MODEH = (GPIO->P[0].MODEH & ~_GPIO_P_MODEH_MODE9_MASK)
			| GPIO_P_MODEH_MODE9_PUSHPULLDRIVE;

	/* Pin PA10 is configured to Input enabled with pull-down and filter */
	GPIO->P[0].MODEH = (GPIO->P[0].MODEH & ~_GPIO_P_MODEH_MODE10_MASK)
			| GPIO_P_MODEH_MODE10_INPUTPULLFILTER;
	// [Port A Configuration]$
        
	// $[Port B Configuration]
        GPIO->P[1].CTRL = (GPIO->P[1].CTRL & ~_GPIO_P_CTRL_DRIVEMODE_MASK)
          | GPIO_P_CTRL_DRIVEMODE_LOW;
        
	/* Pin PB11 is configured to Push-pull with alt. drive strength */
	GPIO->P[1].MODEH = (GPIO->P[1].MODEH & ~_GPIO_P_MODEH_MODE11_MASK)
			| GPIO_P_MODEH_MODE11_PUSHPULLDRIVE;
	// [Port B Configuration]$

	// $[Port C Configuration]

	/* Pin PC0 is configured to Push-pull */
        GPIO->P[2].CTRL = (GPIO->P[2].CTRL & ~_GPIO_P_CTRL_DRIVEMODE_MASK)
          | GPIO_P_CTRL_DRIVEMODE_LOW;
        
	GPIO->P[2].MODEL = (GPIO->P[2].MODEL & ~_GPIO_P_MODEL_MODE0_MASK)
          | GPIO_P_MODEL_MODE0_PUSHPULL;
        
	/* Pin PC1 is configured to Input enabled */
	GPIO->P[2].MODEL = (GPIO->P[2].MODEL & ~_GPIO_P_MODEL_MODE1_MASK)
			| GPIO_P_MODEL_MODE1_INPUT;

	/* Pin PC8 is configured to Push-pull */
	GPIO->P[2].MODEH = (GPIO->P[2].MODEH & ~_GPIO_P_MODEH_MODE8_MASK)
			| GPIO_P_MODEH_MODE8_PUSHPULL;

	/* Pin PC9 is configured to Input enabled */
	GPIO->P[2].MODEH = (GPIO->P[2].MODEH & ~_GPIO_P_MODEH_MODE9_MASK)
			| GPIO_P_MODEH_MODE9_INPUT;

	/* Pin PC10 is configured to Input enabled */
	GPIO->P[2].MODEH = (GPIO->P[2].MODEH & ~_GPIO_P_MODEH_MODE10_MASK)
			| GPIO_P_MODEH_MODE10_INPUT;
	// [Port C Configuration]$
        
	// $[Port D Configuration]
	GPIO->P[3].CTRL = (GPIO->P[3].CTRL & ~_GPIO_P_CTRL_DRIVEMODE_MASK)
          | GPIO_P_CTRL_DRIVEMODE_LOW;
        
	/* Pin PD0 is configured to Push-pull */
	GPIO->P[3].MODEL = (GPIO->P[3].MODEL & ~_GPIO_P_MODEL_MODE0_MASK)
          | GPIO_P_MODEL_MODE0_PUSHPULL;
        
	/* Pin PD1 is configured to Input enabled */
	GPIO->P[3].MODEL = (GPIO->P[3].MODEL & ~_GPIO_P_MODEL_MODE1_MASK)
			| GPIO_P_MODEL_MODE1_INPUT;

	/* Pin PD2 is configured to Input enabled with pull-down and filter */
	GPIO->P[3].MODEL = (GPIO->P[3].MODEL & ~_GPIO_P_MODEL_MODE2_MASK)
			| GPIO_P_MODEL_MODE2_INPUTPULLFILTER;

	/* Pin PD3 is configured to Push-pull */
	GPIO->P[3].MODEL = (GPIO->P[3].MODEL & ~_GPIO_P_MODEL_MODE3_MASK)
			| GPIO_P_MODEL_MODE3_PUSHPULL;

	/* Pin PD4 is configured to Push-pull */
	GPIO->P[3].MODEL = (GPIO->P[3].MODEL & ~_GPIO_P_MODEL_MODE4_MASK)
			| GPIO_P_MODEL_MODE4_PUSHPULL;

	/* Pin PD5 is configured to Push-pull */
	GPIO->P[3].MODEL = (GPIO->P[3].MODEL & ~_GPIO_P_MODEL_MODE5_MASK)
			| GPIO_P_MODEL_MODE5_PUSHPULL;

	/* Pin PD6 is configured to Push-pull with alt. drive strength */
	GPIO->P[3].MODEL = (GPIO->P[3].MODEL & ~_GPIO_P_MODEL_MODE6_MASK)
			| GPIO_P_MODEL_MODE6_PUSHPULLDRIVE;

	/* Pin PD8 is configured to Push-pull with alt. drive strength */
	GPIO->P[3].MODEH = (GPIO->P[3].MODEH & ~_GPIO_P_MODEH_MODE8_MASK)
			| GPIO_P_MODEH_MODE8_PUSHPULLDRIVE;
	// [Port D Configuration]$

	// $[Port E Configuration]
        GPIO->P[4].CTRL = (GPIO->P[4].CTRL & ~_GPIO_P_CTRL_DRIVEMODE_MASK)
          | GPIO_P_CTRL_DRIVEMODE_LOW;
        
	/* Pin PE10 is configured to Push-pull */
	GPIO->P[4].MODEH = (GPIO->P[4].MODEH & ~_GPIO_P_MODEH_MODE10_MASK)
			| GPIO_P_MODEH_MODE10_PUSHPULL;

	/* Pin PE11 is configured to Input enabled */
	GPIO->P[4].MODEH = (GPIO->P[4].MODEH & ~_GPIO_P_MODEH_MODE11_MASK)
			| GPIO_P_MODEH_MODE11_INPUT;

	/* Pin PE12 is configured to Push-pull */
	GPIO->P[4].MODEH = (GPIO->P[4].MODEH & ~_GPIO_P_MODEH_MODE12_MASK)
			| GPIO_P_MODEH_MODE12_PUSHPULL;

	/* Pin PE13 is configured to Push-pull */
	GPIO->P[4].MODEH = (GPIO->P[4].MODEH & ~_GPIO_P_MODEH_MODE13_MASK)
			| GPIO_P_MODEH_MODE13_PUSHPULL;
	// [Port E Configuration]$

	// $[Port F Configuration]
	// [Port F Configuration]$

	// $[Route Configuration]

	/* Enable signals SWO */
	GPIO->ROUTE |= GPIO_ROUTE_SWOPEN;

	/* Enable signals SCL, SDA */
	I2C0->ROUTE |= I2C_ROUTE_SCLPEN | I2C_ROUTE_SDAPEN;

	/* Enable signals CLK, RX, TX */
	USART0->ROUTE |= USART_ROUTE_CLKPEN | USART_ROUTE_RXPEN | USART_ROUTE_TXPEN;

	/* Module USART1 is configured to location 1 */
	USART1->ROUTE = (USART1->ROUTE & ~_USART_ROUTE_LOCATION_MASK)
			| USART_ROUTE_LOCATION_LOC1;

	/* Enable signals RX, TX */
	USART1->ROUTE |= USART_ROUTE_RXPEN | USART_ROUTE_TXPEN;
	// [Route Configuration]$

}

